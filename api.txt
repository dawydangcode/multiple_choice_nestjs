api
9. B·∫£ng topic
API li√™n quan:
POST /api/topics: T·∫°o b·∫£n ghi trong topic.
GET /api/topics: Li·ªát k√™ t·∫•t c·∫£ b·∫£n ghi trong topic.
GET /api/topics/{id}: Truy v·∫•n b·∫£n ghi c·ª• th·ªÉ trong topic.
PUT /api/topics/{id}: C·∫≠p nh·∫≠t b·∫£n ghi trong topic.
DELETE /api/topics/{id}: X√≥a m·ªÅm b·∫£n ghi trong topic (c·∫≠p nh·∫≠t deleted_at, deleted_by).
Ghi ch√∫: ƒê∆∞·ª£c tham chi·∫øu b·ªüi question qua topic_id.

10. B·∫£ng exam
API li√™n quan:
POST /api/exams: T·∫°o b·∫£n ghi trong exam.
GET /api/exams: Li·ªát k√™ t·∫•t c·∫£ b·∫£n ghi trong exam.
GET /api/exams/{id}: Truy v·∫•n b·∫£n ghi c·ª• th·ªÉ trong exam.
PUT /api/exams/{id}: C·∫≠p nh·∫≠t b·∫£n ghi trong exam.
DELETE /api/exams/{id}: X√≥a m·ªÅm b·∫£n ghi trong exam (c·∫≠p nh·∫≠t deleted_at, deleted_by).
GET /api/users/{user_id}/pick-exams: Truy v·∫•n exam ƒë·ªÉ l·∫•y th√¥ng tin b√†i thi (nh∆∞ title).
Ghi ch√∫: L∆∞u th√¥ng tin b√†i thi (ti√™u ƒë·ªÅ, th·ªùi gian, tr·∫°ng th√°i).

11. B·∫£ng question
API li√™n quan:
POST /api/questions: T·∫°o b·∫£n ghi trong question.
GET /api/questions: Li·ªát k√™ t·∫•t c·∫£ b·∫£n ghi trong question.
GET /api/questions/{id}: Truy v·∫•n b·∫£n ghi c·ª• th·ªÉ trong question.
PUT /api/questions/{id}: C·∫≠p nh·∫≠t b·∫£n ghi trong question.
DELETE /api/questions/{id}: X√≥a m·ªÅm b·∫£n ghi trong question (c·∫≠p nh·∫≠t deleted_at, deleted_by).

GET /api/exams/{id}: Truy v·∫•n question th√¥ng qua exam_question.
GET /api/exam-questions/{exam_id}: Truy v·∫•n question ƒë·ªÉ l·∫•y c√¢u h·ªèi c·ªßa b√†i thi.
POST /api/pick-exams/{pick_exam_id}/submit: Truy v·∫•n question ƒë·ªÉ l·∫•y points khi t√≠nh ƒëi·ªÉm.
GET /api/pick-exams/{id}: Truy v·∫•n question ƒë·ªÉ l·∫•y chi ti·∫øt c√¢u h·ªèi trong l∆∞·ª£t l√†m b√†i.
Ghi ch√∫: L∆∞u n·ªôi dung c√¢u h·ªèi v√† ƒëi·ªÉm s·ªë, li√™n k·∫øt v·ªõi topic.
12. B·∫£ng answer
API li√™n quan:
POST /api/questions: T·∫°o b·∫£n ghi trong answer (c√πng v·ªõi c√¢u h·ªèi).
GET /api/questions: Li·ªát k√™ answer c√πng v·ªõi question.
GET /api/questions/{id}: Truy v·∫•n answer cho c√¢u h·ªèi c·ª• th·ªÉ.
PUT /api/questions/{id}: C·∫≠p nh·∫≠t b·∫£n ghi trong answer.
DELETE /api/questions/{id}: X√≥a m·ªÅm b·∫£n ghi trong answer (c√πng v·ªõi c√¢u h·ªèi).
GET /api/exams/{id}: Truy v·∫•n answer th√¥ng qua exam_question v√† question.
GET /api/exam-questions/{exam_id}: Truy v·∫•n answer ƒë·ªÉ l·∫•y c√¢u tr·∫£ l·ªùi c·ªßa c√¢u h·ªèi.
POST /api/pick-exams/{pick_exam_id}/submit: Truy v·∫•n answer ƒë·ªÉ ki·ªÉm tra is_correct khi t√≠nh ƒëi·ªÉm.
GET /api/pick-exams/{id}: Truy v·∫•n answer ƒë·ªÉ l·∫•y chi ti·∫øt c√¢u tr·∫£ l·ªùi trong l∆∞·ª£t l√†m b√†i.
Ghi ch√∫: L∆∞u c√¢u tr·∫£ l·ªùi v√† tr·∫°ng th√°i ƒë√∫ng/sai, li√™n k·∫øt v·ªõi question.
13. B·∫£ng exam_question
API li√™n quan:
POST /api/exam-questions: T·∫°o b·∫£n ghi trong exam_question.
GET /api/exam-questions/{exam_id}: Li·ªát k√™ t·∫•t c·∫£ b·∫£n ghi trong exam_question cho b√†i thi.
DELETE /api/exam-questions/{id}: X√≥a m·ªÅm b·∫£n ghi trong exam_question (c·∫≠p nh·∫≠t deleted_at, deleted_by).
GET /api/exams/{id}: Truy v·∫•n exam_question ƒë·ªÉ l·∫•y danh s√°ch c√¢u h·ªèi c·ªßa b√†i thi.
Ghi ch√∫: Li√™n k·∫øt gi·ªØa exam v√† question.

14. B·∫£ng pick_exam
API li√™n quan:
POST /api/pick-exams: T·∫°o b·∫£n ghi trong pick_exam (b·∫Øt ƒë·∫ßu b√†i thi).
GET /api/pick-exams/{id}: Truy v·∫•n b·∫£n ghi c·ª• th·ªÉ trong pick_exam.
GET /api/users/{user_id}/pick-exams: Li·ªát k√™ t·∫•t c·∫£ b·∫£n ghi trong pick_exam cho ng∆∞·ªùi d√πng.
Ghi ch√∫: L∆∞u th√¥ng tin l∆∞·ª£t l√†m b√†i thi (ng∆∞·ªùi d√πng, b√†i thi, th·ªùi gian).
15. B·∫£ng pick_exam_detail
API li√™n quan:
POST /api/pick-exams/{pick_exam_id}/submit: T·∫°o b·∫£n ghi trong pick_exam_detail (l∆∞u c√¢u tr·∫£ l·ªùi c·ªßa ng∆∞·ªùi d√πng).
GET /api/pick-exams/{id}: Truy v·∫•n pick_exam_detail ƒë·ªÉ l·∫•y chi ti·∫øt c√¢u tr·∫£ l·ªùi.
GET /api/users/{user_id}/pick-exams: Truy v·∫•n pick_exam_detail ƒë·ªÉ t√≠nh ƒëi·ªÉm t·ªïng.
Ghi ch√∫: L∆∞u c√¢u tr·∫£ l·ªùi c·ª• th·ªÉ c·ªßa ng∆∞·ªùi d√πng trong l∆∞·ª£t l√†m b√†i.

b√†i thi t·ª± ƒë·ªông k·∫øt th√∫c, ng∆∞·ªùi d·ª± thi k·∫øt th√∫c b√†i thi 
	+ n·∫øu b√†i thi t·ª± ƒë·ªông k·∫øt th√∫c, l·∫•y current time l√†m finishTime => t·ªïng th·ªùi gian l√†m b√†i
	+ n·∫øu b√†i thi k·∫øt th√∫c b·ªüi ng∆∞·ªùi d·ª± thi: EXAM_DURATION - currenttime - startTime
khi k·∫øt th√∫c b√†i thi s·∫Ω g·ª≠i array question answer -> check c√¢u tr·∫£ l·ªùi c·ªßa ng∆∞·ªùi user v·ªõi array ƒë√°p √°n c·ªßa ƒë·ªÅ thi
=> total points

question : phan page, sap xep

exam: rm active/deactive -> update

g·ªôp validate logic 

pagiation

Delete Column Dead ... 

khoong lay cung relations

fix pagination

gop nhung component trong get 's 

pick exam detail dto XXXX

mysql transaction

ham` tinh toan ko get thong tin pickExam -> getPickExamDetail

check question + exam khi submit answer

VALIDATE SUBMIT ANSWER

T√¥i s·∫Ω gi√∫p b·∫°n th√™m validation ch·ªëng gian l·∫≠n khi submit b√†i thi. ƒê√¢y l√† version c√≥ ƒë·∫ßy ƒë·ªß security checks:

‚úÖ Enhanced submitPickExamWithAnswers v·ªõi Anti-Cheat Validation:

async submitPickExamWithAnswers(
  pickExam: PickExamModel,
  submitAnswer: SubmitAnswersBodyDto,
  reqAccountId: number,
): Promise<PickExamModel> {
  // ‚úÖ 1. Validate pick exam exists
  await this.getPickExamById(pickExam.id);

  // ‚úÖ 2. Validate exam is in progress
  const pickExamResults = await this.getPickExams(
    [pickExam.id],
    undefined,
    undefined,
    PickExamType.IN_PROGRESS,
    undefined,
    undefined,
    undefined,
  );

  if (pickExamResults.total === 0) {
    throw new BadRequestException('Pick exam is not in progress');
  }

  // ‚úÖ 3. Validate exam hasn't expired
  const currentPickExam = pickExamResults.data[0];
  const now = new Date();
  if (now > currentPickExam.endTime) {
    throw new BadRequestException('Exam time has expired');
  }

  // ‚úÖ 4. Get exam with questions and answers for validation
  const examModel = await this.examService.getExamById(currentPickExam.examId);
  const examWithQuestions = await this.examService.getExamWithQuestionsAndAnswersById(examModel);

  // ‚úÖ 5. Validate submitted answers against exam questions
  await this.validateSubmittedAnswers(examWithQuestions, submitAnswer.answers);

  // ‚úÖ 6. Save each answer individually with validation
  for (const answer of submitAnswer.answers) {
    console.log(`Processing answer for question ${answer.questionId}`);
    
    // ‚úÖ Additional validation per answer
    await this.validateIndividualAnswer(examWithQuestions, answer.questionId, answer.answerId);
    
    const pickExamDto = new PickExamDetailDto();
    pickExamDto.questionId = answer.questionId;
    pickExamDto.answerId = answer.answerId;
    pickExamDto.reqAccountId = reqAccountId;

    await this.pickExamDetailService.savePickExamDetails(
      pickExam.id,
      [pickExamDto],
      reqAccountId,
    );

    console.log(`‚úÖ Saved valid answer for question ${answer.questionId}`);
  }

  const score = await this.pickExamDetailService.calculateScore(pickExam.id);

  await this.pickExamRepository.update(
    {
      id: pickExam.id,
      deletedAt: IsNull(),
    },
    {
      status: PickExamType.COMPLETED,
      finishTime: new Date(),
      totalQuestions: score.totalQuestions,
      correctAnswers: score.correctAnswers,
      score: score.score,
      percentage: score.percentage,
      updatedAt: new Date(),
      updatedBy: reqAccountId,
    },
  );

  return await this.getPickExamById(pickExam.id);
}

‚úÖ Th√™m c√°c validation methods:
// ‚úÖ Validate t·∫•t c·∫£ c√¢u tr·∫£ l·ªùi ƒë∆∞·ª£c submit
private async validateSubmittedAnswers(
  examWithQuestions: ExamQuestionAnswerModel,
  submittedAnswers: Array<{ questionId: number; answerId: number }>,
): Promise<void> {
  console.log('üîç Validating submitted answers...');

  // ‚úÖ Check if exam has questions
  if (examWithQuestions.totalQuestions === 0) {
    throw new BadRequestException('Exam has no questions');
  }

  // ‚úÖ Validate number of submitted answers
  if (submittedAnswers.length === 0) {
    throw new BadRequestException('No answers submitted');
  }

  if (submittedAnswers.length > examWithQuestions.totalQuestions) {
    throw new BadRequestException(
      `Too many answers submitted. Expected max: ${examWithQuestions.totalQuestions}, got: ${submittedAnswers.length}`
    );
  }

  // ‚úÖ Check for duplicate question IDs
  const questionIds = submittedAnswers.map(a => a.questionId);
  const uniqueQuestionIds = new Set(questionIds);
  if (questionIds.length !== uniqueQuestionIds.size) {
    throw new BadRequestException('Duplicate answers for the same question are not allowed');
  }

  // ‚úÖ Validate each question exists in exam
  const examQuestionIds = examWithQuestions.questions.map(q => q.id);
  for (const answer of submittedAnswers) {
    if (!examQuestionIds.includes(answer.questionId)) {
      throw new BadRequestException(
        `Question ID ${answer.questionId} is not part of this exam`
      );
    }
  }

  console.log(`‚úÖ All ${submittedAnswers.length} submitted answers are valid`);
}

// ‚úÖ Validate t·ª´ng c√¢u tr·∫£ l·ªùi c·ª• th·ªÉ
private async validateIndividualAnswer(
  examWithQuestions: ExamQuestionAnswerModel,
  questionId: number,
  answerId: number,
): Promise<void> {
  // ‚úÖ Find question in exam
  const question = examWithQuestions.questions.find(q => q.id === questionId);
  if (!question) {
    throw new BadRequestException(`Question ${questionId} not found in this exam`);
  }

  // ‚úÖ Check if answer belongs to this question
  const validAnswer = question.answers.find(a => a.id === answerId);
  if (!validAnswer) {
    throw new BadRequestException(
      `Answer ${answerId} is not valid for question ${questionId}`
    );
  }

  // ‚úÖ Additional check: Verify answer exists in database
  const answerFromDb = await this.validateAnswerInDatabase(questionId, answerId);
  if (!answerFromDb) {
    throw new BadRequestException(
      `Answer ${answerId} does not exist in database for question ${questionId}`
    );
  }

  console.log(`‚úÖ Answer ${answerId} is valid for question ${questionId}`);
}

// ‚úÖ Validate answer t·ªìn t·∫°i trong database
private async validateAnswerInDatabase(
  questionId: number,
  answerId: number,
): Promise<boolean> {
  try {
    // ‚úÖ Direct database check ƒë·ªÉ ƒë·∫£m b·∫£o data integrity
    const answerExists = await this.pickExamDetailService.checkAnswerExists(questionId, answerId);
    return answerExists;
  } catch (error) {
    console.error(`Error validating answer in database:`, error);
    return false;
  }
}

‚úÖ Th√™m method v√†o PickExamDetailService:
// Th√™m v√†o PickExamDetailService
async checkAnswerExists(questionId: number, answerId: number): Promise<boolean> {
  const query = `
    SELECT COUNT(*) as count 
    FROM answer a 
    WHERE a.id = ? 
    AND a.question_id = ? 
    AND a.deleted_at IS NULL
  `;
  
  const result = await this.pickExamDetailRepository.query(query, [answerId, questionId]);
  return result[0]?.count > 0;
}

‚úÖ Enhanced version v·ªõi th√™m security checks:

async submitPickExamWithAnswers(
  pickExam: PickExamModel,
  submitAnswer: SubmitAnswersBodyDto,
  reqAccountId: number,
): Promise<PickExamModel> {
  console.log(`üîê Starting secure exam submission for pickExam ${pickExam.id}`);

  // ‚úÖ 1. Basic validations
  await this.getPickExamById(pickExam.id);

  const pickExamResults = await this.getPickExams(
    [pickExam.id],
    undefined,
    undefined,
    PickExamType.IN_PROGRESS,
    undefined,
    undefined,
    undefined,
  );

  if (pickExamResults.total === 0) {
    throw new BadRequestException('Pick exam is not in progress');
  }

  const currentPickExam = pickExamResults.data[0];

  // ‚úÖ 2. Time validation
  const now = new Date();
  if (now > currentPickExam.endTime) {
    console.warn(`‚ö†Ô∏è Exam ${pickExam.id} submission after deadline. EndTime: ${currentPickExam.endTime}, Now: ${now}`);
    throw new BadRequestException('Exam time has expired');
  }

  // ‚úÖ 3. Prevent multiple submissions
  const existingSubmission = await this.pickExamDetailService.checkExistingSubmission(pickExam.id);
  if (existingSubmission) {
    throw new BadRequestException('Exam has already been submitted');
  }

  // ‚úÖ 4. Get exam structure for validation
  const examModel = await this.examService.getExamById(currentPickExam.examId);
  const examWithQuestions = await this.examService.getExamWithQuestionsAndAnswersById(examModel);

  // ‚úÖ 5. Comprehensive validation
  await this.validateSubmittedAnswers(examWithQuestions, submitAnswer.answers);

  // ‚úÖ 6. Additional security checks
  await this.performSecurityChecks(pickExam.id, reqAccountId, submitAnswer.answers);

  // ‚úÖ 7. Save answers with validation
  const savedAnswers: number[] = [];
  try {
    for (const answer of submitAnswer.answers) {
      await this.validateIndividualAnswer(examWithQuestions, answer.questionId, answer.answerId);
      
      const pickExamDto = new PickExamDetailDto();
      pickExamDto.questionId = answer.questionId;
      pickExamDto.answerId = answer.answerId;
      pickExamDto.reqAccountId = reqAccountId;

      await this.pickExamDetailService.savePickExamDetails(
        pickExam.id,
        [pickExamDto],
        reqAccountId,
      );

      savedAnswers.push(answer.questionId);
      console.log(`‚úÖ Saved secure answer for question ${answer.questionId}`);
    }
  } catch (error) {
    console.error(`‚ùå Failed to save answers. Successfully saved: ${savedAnswers.join(', ')}`);
    throw error;
  }

  // ‚úÖ 8. Calculate score and complete exam
  const score = await this.pickExamDetailService.calculateScore(pickExam.id);

  await this.pickExamRepository.update(
    {
      id: pickExam.id,
      deletedAt: IsNull(),
    },
    {
      status: PickExamType.COMPLETED,
      finishTime: new Date(),
      totalQuestions: score.totalQuestions,
      correctAnswers: score.correctAnswers,
      score: score.score,
      percentage: score.percentage,
      updatedAt: new Date(),
      updatedBy: reqAccountId,
    },
  );

  console.log(`üéâ Exam ${pickExam.id} completed successfully with score: ${score.score}/${score.totalQuestions}`);

  return await this.getPickExamById(pickExam.id);
}

// ‚úÖ Additional security checks
private async performSecurityChecks(
  pickExamId: number,
  reqAccountId: number,
  answers: Array<{ questionId: number; answerId: number }>,
): Promise<void> {
  console.log('üîê Performing additional security checks...');

  // ‚úÖ Check submission rate (prevent rapid fire submissions)
  const recentSubmissions = await this.checkRecentSubmissions(reqAccountId);
  if (recentSubmissions > 5) { // Max 5 submissions in last minute
    throw new BadRequestException('Too many submission attempts. Please wait.');
  }

  // ‚úÖ Validate answer pattern (detect suspicious patterns)
  this.validateAnswerPattern(answers);

  console.log('‚úÖ Security checks passed');
}

private async checkRecentSubmissions(accountId: number): Promise<number> {
  const oneMinuteAgo = new Date(Date.now() - 60000);
  const count = await this.pickExamRepository.count({
    where: {
      createdBy: accountId,
      createdAt: MoreThan(oneMinuteAgo),
    },
  });
  return count;
}

private validateAnswerPattern(answers: Array<{ questionId: number; answerId: number }>): void {
  // ‚úÖ Detect suspicious patterns (e.g., all same answer ID)
  const answerIds = answers.map(a => a.answerId);
  const uniqueAnswerIds = new Set(answerIds);
  
  if (uniqueAnswerIds.size === 1 && answers.length > 3) {
    console.warn('‚ö†Ô∏è Suspicious answer pattern detected: all same answer');
    // Could log for admin review but don't block automatically
  }

  // ‚úÖ Check for sequential answer IDs (another suspicious pattern)
  const sortedAnswerIds = [...answerIds].sort((a, b) => a - b);
  let sequential = 0;
  for (let i = 1; i < sortedAnswerIds.length; i++) {
    if (sortedAnswerIds[i] === sortedAnswerIds[i-1] + 1) {
      sequential++;
    }
  }
  
  if (sequential === sortedAnswerIds.length - 1 && answers.length > 5) {
    console.warn('‚ö†Ô∏è Suspicious answer pattern detected: sequential answer IDs');
  }
}

üîê Security Features ƒë∆∞·ª£c th√™m:
‚úÖ Question-Answer Validation - ƒê·∫£m b·∫£o answer thu·ªôc v·ªÅ question ƒë√∫ng
‚úÖ Database Integrity Check - Verify answer t·ªìn t·∫°i trong DB
‚úÖ Time Validation - Prevent submission sau deadline
‚úÖ Duplicate Prevention - Kh√¥ng cho ph√©p submit nhi·ªÅu l·∫ßn
‚úÖ Rate Limiting - Gi·ªõi h·∫°n s·ªë l·∫ßn submit trong th·ªùi gian ng·∫Øn
‚úÖ Pattern Detection - Ph√°t hi·ªán pattern ƒë√°ng ng·ªù
‚úÖ Data Integrity - Validate structure c·ªßa exam v√† answers
